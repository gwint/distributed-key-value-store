/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "replicaservice_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




Entry::~Entry() noexcept {
}


void Entry::__set_key(const std::string& val) {
  this->key = val;
}

void Entry::__set_value(const std::string& val) {
  this->value = val;
}

void Entry::__set_term(const int32_t val) {
  this->term = val;
}

void Entry::__set_clientIdentifier(const std::string& val) {
  this->clientIdentifier = val;
}

void Entry::__set_requestIdentifier(const int32_t val) {
  this->requestIdentifier = val;
}
std::ostream& operator<<(std::ostream& out, const Entry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Entry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientIdentifier);
          this->__isset.clientIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->requestIdentifier);
          this->__isset.requestIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Entry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Entry");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clientIdentifier", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->clientIdentifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestIdentifier", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->requestIdentifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Entry &a, Entry &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.term, b.term);
  swap(a.clientIdentifier, b.clientIdentifier);
  swap(a.requestIdentifier, b.requestIdentifier);
  swap(a.__isset, b.__isset);
}

Entry::Entry(const Entry& other0) {
  key = other0.key;
  value = other0.value;
  term = other0.term;
  clientIdentifier = other0.clientIdentifier;
  requestIdentifier = other0.requestIdentifier;
  __isset = other0.__isset;
}
Entry& Entry::operator=(const Entry& other1) {
  key = other1.key;
  value = other1.value;
  term = other1.term;
  clientIdentifier = other1.clientIdentifier;
  requestIdentifier = other1.requestIdentifier;
  __isset = other1.__isset;
  return *this;
}
void Entry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Entry(";
  out << "key=" << to_string(key);
  out << ", " << "value=" << to_string(value);
  out << ", " << "term=" << to_string(term);
  out << ", " << "clientIdentifier=" << to_string(clientIdentifier);
  out << ", " << "requestIdentifier=" << to_string(requestIdentifier);
  out << ")";
}


AppendEntryResponse::~AppendEntryResponse() noexcept {
}


void AppendEntryResponse::__set_success(const bool val) {
  this->success = val;
}

void AppendEntryResponse::__set_term(const int32_t val) {
  this->term = val;
}

void AppendEntryResponse::__set_prevLogIndex(const int32_t val) {
  this->prevLogIndex = val;
}

void AppendEntryResponse::__set_numberOfEntriesAdded(const int32_t val) {
  this->numberOfEntriesAdded = val;
}
std::ostream& operator<<(std::ostream& out, const AppendEntryResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppendEntryResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->prevLogIndex);
          this->__isset.prevLogIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numberOfEntriesAdded);
          this->__isset.numberOfEntriesAdded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppendEntryResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppendEntryResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prevLogIndex", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->prevLogIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numberOfEntriesAdded", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->numberOfEntriesAdded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppendEntryResponse &a, AppendEntryResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.term, b.term);
  swap(a.prevLogIndex, b.prevLogIndex);
  swap(a.numberOfEntriesAdded, b.numberOfEntriesAdded);
  swap(a.__isset, b.__isset);
}

AppendEntryResponse::AppendEntryResponse(const AppendEntryResponse& other2) {
  success = other2.success;
  term = other2.term;
  prevLogIndex = other2.prevLogIndex;
  numberOfEntriesAdded = other2.numberOfEntriesAdded;
  __isset = other2.__isset;
}
AppendEntryResponse& AppendEntryResponse::operator=(const AppendEntryResponse& other3) {
  success = other3.success;
  term = other3.term;
  prevLogIndex = other3.prevLogIndex;
  numberOfEntriesAdded = other3.numberOfEntriesAdded;
  __isset = other3.__isset;
  return *this;
}
void AppendEntryResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppendEntryResponse(";
  out << "success=" << to_string(success);
  out << ", " << "term=" << to_string(term);
  out << ", " << "prevLogIndex=" << to_string(prevLogIndex);
  out << ", " << "numberOfEntriesAdded=" << to_string(numberOfEntriesAdded);
  out << ")";
}


Ballot::~Ballot() noexcept {
}


void Ballot::__set_voteGranted(const bool val) {
  this->voteGranted = val;
}

void Ballot::__set_term(const int32_t val) {
  this->term = val;
}
std::ostream& operator<<(std::ostream& out, const Ballot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Ballot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->voteGranted);
          this->__isset.voteGranted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Ballot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Ballot");

  xfer += oprot->writeFieldBegin("voteGranted", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->voteGranted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Ballot &a, Ballot &b) {
  using ::std::swap;
  swap(a.voteGranted, b.voteGranted);
  swap(a.term, b.term);
  swap(a.__isset, b.__isset);
}

Ballot::Ballot(const Ballot& other4) {
  voteGranted = other4.voteGranted;
  term = other4.term;
  __isset = other4.__isset;
}
Ballot& Ballot::operator=(const Ballot& other5) {
  voteGranted = other5.voteGranted;
  term = other5.term;
  __isset = other5.__isset;
  return *this;
}
void Ballot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Ballot(";
  out << "voteGranted=" << to_string(voteGranted);
  out << ", " << "term=" << to_string(term);
  out << ")";
}


ID::~ID() noexcept {
}


void ID::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void ID::__set_port(const int32_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const ID& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ID::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          this->__isset.hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ID");

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ID &a, ID &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

ID::ID(const ID& other6) {
  hostname = other6.hostname;
  port = other6.port;
  __isset = other6.__isset;
}
ID& ID::operator=(const ID& other7) {
  hostname = other7.hostname;
  port = other7.port;
  __isset = other7.__isset;
  return *this;
}
void ID::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ID(";
  out << "hostname=" << to_string(hostname);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


PutResponse::~PutResponse() noexcept {
}


void PutResponse::__set_success(const int32_t val) {
  this->success = val;
}

void PutResponse::__set_leaderID(const ID& val) {
  this->leaderID = val;
}
std::ostream& operator<<(std::ostream& out, const PutResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PutResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->leaderID.read(iprot);
          this->__isset.leaderID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PutResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PutResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leaderID", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->leaderID.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PutResponse &a, PutResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.leaderID, b.leaderID);
  swap(a.__isset, b.__isset);
}

PutResponse::PutResponse(const PutResponse& other8) {
  success = other8.success;
  leaderID = other8.leaderID;
  __isset = other8.__isset;
}
PutResponse& PutResponse::operator=(const PutResponse& other9) {
  success = other9.success;
  leaderID = other9.leaderID;
  __isset = other9.__isset;
  return *this;
}
void PutResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PutResponse(";
  out << "success=" << to_string(success);
  out << ", " << "leaderID=" << to_string(leaderID);
  out << ")";
}


GetResponse::~GetResponse() noexcept {
}


void GetResponse::__set_success(const bool val) {
  this->success = val;
}

void GetResponse::__set_value(const std::string& val) {
  this->value = val;
}

void GetResponse::__set_leaderID(const ID& val) {
  this->leaderID = val;
}
std::ostream& operator<<(std::ostream& out, const GetResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->leaderID.read(iprot);
          this->__isset.leaderID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leaderID", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->leaderID.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetResponse &a, GetResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.value, b.value);
  swap(a.leaderID, b.leaderID);
  swap(a.__isset, b.__isset);
}

GetResponse::GetResponse(const GetResponse& other10) {
  success = other10.success;
  value = other10.value;
  leaderID = other10.leaderID;
  __isset = other10.__isset;
}
GetResponse& GetResponse::operator=(const GetResponse& other11) {
  success = other11.success;
  value = other11.value;
  leaderID = other11.leaderID;
  __isset = other11.__isset;
  return *this;
}
void GetResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetResponse(";
  out << "success=" << to_string(success);
  out << ", " << "value=" << to_string(value);
  out << ", " << "leaderID=" << to_string(leaderID);
  out << ")";
}


