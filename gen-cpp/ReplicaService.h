/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ReplicaService_H
#define ReplicaService_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "replicaservice_types.h"



#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class ReplicaServiceIf {
 public:
  virtual ~ReplicaServiceIf() {}
  virtual void requestVote(Ballot& _return, const int32_t term, const ID& candidateID, const int32_t lastLogIndex, const int32_t lastLogTerm) = 0;
  virtual void appendEntry(AppendEntryResponse& _return, const int32_t term, const ID& leaderID, const int32_t prevLogIndex, const int32_t prevLogTerm, const Entry& entry, const int32_t leaderCommit) = 0;
  virtual void get(GetResponse& _return, const std::string& key, const std::string& clientIdentifier, const int32_t requestIdentifier) = 0;
  virtual void put(PutResponse& _return, const std::string& key, const std::string& value, const std::string& clientIdentifier, const int32_t requestIdentifier) = 0;
  virtual void kill() = 0;
  virtual void getInformation(std::map<std::string, std::string> & _return) = 0;
  virtual void start() = 0;
};

class ReplicaServiceIfFactory {
 public:
  typedef ReplicaServiceIf Handler;

  virtual ~ReplicaServiceIfFactory() {}

  virtual ReplicaServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ReplicaServiceIf* /* handler */) = 0;
};

class ReplicaServiceIfSingletonFactory : virtual public ReplicaServiceIfFactory {
 public:
  ReplicaServiceIfSingletonFactory(const ::std::shared_ptr<ReplicaServiceIf>& iface) : iface_(iface) {}
  virtual ~ReplicaServiceIfSingletonFactory() {}

  virtual ReplicaServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ReplicaServiceIf* /* handler */) {}

 protected:
  ::std::shared_ptr<ReplicaServiceIf> iface_;
};

class ReplicaServiceNull : virtual public ReplicaServiceIf {
 public:
  virtual ~ReplicaServiceNull() {}
  void requestVote(Ballot& /* _return */, const int32_t /* term */, const ID& /* candidateID */, const int32_t /* lastLogIndex */, const int32_t /* lastLogTerm */) {
    return;
  }
  void appendEntry(AppendEntryResponse& /* _return */, const int32_t /* term */, const ID& /* leaderID */, const int32_t /* prevLogIndex */, const int32_t /* prevLogTerm */, const Entry& /* entry */, const int32_t /* leaderCommit */) {
    return;
  }
  void get(GetResponse& /* _return */, const std::string& /* key */, const std::string& /* clientIdentifier */, const int32_t /* requestIdentifier */) {
    return;
  }
  void put(PutResponse& /* _return */, const std::string& /* key */, const std::string& /* value */, const std::string& /* clientIdentifier */, const int32_t /* requestIdentifier */) {
    return;
  }
  void kill() {
    return;
  }
  void getInformation(std::map<std::string, std::string> & /* _return */) {
    return;
  }
  void start() {
    return;
  }
};

typedef struct _ReplicaService_requestVote_args__isset {
  _ReplicaService_requestVote_args__isset() : term(false), candidateID(false), lastLogIndex(false), lastLogTerm(false) {}
  bool term :1;
  bool candidateID :1;
  bool lastLogIndex :1;
  bool lastLogTerm :1;
} _ReplicaService_requestVote_args__isset;

class ReplicaService_requestVote_args {
 public:

  ReplicaService_requestVote_args(const ReplicaService_requestVote_args&);
  ReplicaService_requestVote_args& operator=(const ReplicaService_requestVote_args&);
  ReplicaService_requestVote_args() : term(0), lastLogIndex(0), lastLogTerm(0) {
  }

  virtual ~ReplicaService_requestVote_args() noexcept;
  int32_t term;
  ID candidateID;
  int32_t lastLogIndex;
  int32_t lastLogTerm;

  _ReplicaService_requestVote_args__isset __isset;

  void __set_term(const int32_t val);

  void __set_candidateID(const ID& val);

  void __set_lastLogIndex(const int32_t val);

  void __set_lastLogTerm(const int32_t val);

  bool operator == (const ReplicaService_requestVote_args & rhs) const
  {
    if (!(term == rhs.term))
      return false;
    if (!(candidateID == rhs.candidateID))
      return false;
    if (!(lastLogIndex == rhs.lastLogIndex))
      return false;
    if (!(lastLogTerm == rhs.lastLogTerm))
      return false;
    return true;
  }
  bool operator != (const ReplicaService_requestVote_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_requestVote_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ReplicaService_requestVote_pargs {
 public:


  virtual ~ReplicaService_requestVote_pargs() noexcept;
  const int32_t* term;
  const ID* candidateID;
  const int32_t* lastLogIndex;
  const int32_t* lastLogTerm;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_requestVote_result__isset {
  _ReplicaService_requestVote_result__isset() : success(false) {}
  bool success :1;
} _ReplicaService_requestVote_result__isset;

class ReplicaService_requestVote_result {
 public:

  ReplicaService_requestVote_result(const ReplicaService_requestVote_result&);
  ReplicaService_requestVote_result& operator=(const ReplicaService_requestVote_result&);
  ReplicaService_requestVote_result() {
  }

  virtual ~ReplicaService_requestVote_result() noexcept;
  Ballot success;

  _ReplicaService_requestVote_result__isset __isset;

  void __set_success(const Ballot& val);

  bool operator == (const ReplicaService_requestVote_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ReplicaService_requestVote_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_requestVote_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_requestVote_presult__isset {
  _ReplicaService_requestVote_presult__isset() : success(false) {}
  bool success :1;
} _ReplicaService_requestVote_presult__isset;

class ReplicaService_requestVote_presult {
 public:


  virtual ~ReplicaService_requestVote_presult() noexcept;
  Ballot* success;

  _ReplicaService_requestVote_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ReplicaService_appendEntry_args__isset {
  _ReplicaService_appendEntry_args__isset() : term(false), leaderID(false), prevLogIndex(false), prevLogTerm(false), entry(false), leaderCommit(false) {}
  bool term :1;
  bool leaderID :1;
  bool prevLogIndex :1;
  bool prevLogTerm :1;
  bool entry :1;
  bool leaderCommit :1;
} _ReplicaService_appendEntry_args__isset;

class ReplicaService_appendEntry_args {
 public:

  ReplicaService_appendEntry_args(const ReplicaService_appendEntry_args&);
  ReplicaService_appendEntry_args& operator=(const ReplicaService_appendEntry_args&);
  ReplicaService_appendEntry_args() : term(0), prevLogIndex(0), prevLogTerm(0), leaderCommit(0) {
  }

  virtual ~ReplicaService_appendEntry_args() noexcept;
  int32_t term;
  ID leaderID;
  int32_t prevLogIndex;
  int32_t prevLogTerm;
  Entry entry;
  int32_t leaderCommit;

  _ReplicaService_appendEntry_args__isset __isset;

  void __set_term(const int32_t val);

  void __set_leaderID(const ID& val);

  void __set_prevLogIndex(const int32_t val);

  void __set_prevLogTerm(const int32_t val);

  void __set_entry(const Entry& val);

  void __set_leaderCommit(const int32_t val);

  bool operator == (const ReplicaService_appendEntry_args & rhs) const
  {
    if (!(term == rhs.term))
      return false;
    if (!(leaderID == rhs.leaderID))
      return false;
    if (!(prevLogIndex == rhs.prevLogIndex))
      return false;
    if (!(prevLogTerm == rhs.prevLogTerm))
      return false;
    if (!(entry == rhs.entry))
      return false;
    if (!(leaderCommit == rhs.leaderCommit))
      return false;
    return true;
  }
  bool operator != (const ReplicaService_appendEntry_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_appendEntry_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ReplicaService_appendEntry_pargs {
 public:


  virtual ~ReplicaService_appendEntry_pargs() noexcept;
  const int32_t* term;
  const ID* leaderID;
  const int32_t* prevLogIndex;
  const int32_t* prevLogTerm;
  const Entry* entry;
  const int32_t* leaderCommit;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_appendEntry_result__isset {
  _ReplicaService_appendEntry_result__isset() : success(false) {}
  bool success :1;
} _ReplicaService_appendEntry_result__isset;

class ReplicaService_appendEntry_result {
 public:

  ReplicaService_appendEntry_result(const ReplicaService_appendEntry_result&);
  ReplicaService_appendEntry_result& operator=(const ReplicaService_appendEntry_result&);
  ReplicaService_appendEntry_result() {
  }

  virtual ~ReplicaService_appendEntry_result() noexcept;
  AppendEntryResponse success;

  _ReplicaService_appendEntry_result__isset __isset;

  void __set_success(const AppendEntryResponse& val);

  bool operator == (const ReplicaService_appendEntry_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ReplicaService_appendEntry_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_appendEntry_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_appendEntry_presult__isset {
  _ReplicaService_appendEntry_presult__isset() : success(false) {}
  bool success :1;
} _ReplicaService_appendEntry_presult__isset;

class ReplicaService_appendEntry_presult {
 public:


  virtual ~ReplicaService_appendEntry_presult() noexcept;
  AppendEntryResponse* success;

  _ReplicaService_appendEntry_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ReplicaService_get_args__isset {
  _ReplicaService_get_args__isset() : key(false), clientIdentifier(false), requestIdentifier(false) {}
  bool key :1;
  bool clientIdentifier :1;
  bool requestIdentifier :1;
} _ReplicaService_get_args__isset;

class ReplicaService_get_args {
 public:

  ReplicaService_get_args(const ReplicaService_get_args&);
  ReplicaService_get_args& operator=(const ReplicaService_get_args&);
  ReplicaService_get_args() : key(), clientIdentifier(), requestIdentifier(0) {
  }

  virtual ~ReplicaService_get_args() noexcept;
  std::string key;
  std::string clientIdentifier;
  int32_t requestIdentifier;

  _ReplicaService_get_args__isset __isset;

  void __set_key(const std::string& val);

  void __set_clientIdentifier(const std::string& val);

  void __set_requestIdentifier(const int32_t val);

  bool operator == (const ReplicaService_get_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(clientIdentifier == rhs.clientIdentifier))
      return false;
    if (!(requestIdentifier == rhs.requestIdentifier))
      return false;
    return true;
  }
  bool operator != (const ReplicaService_get_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_get_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ReplicaService_get_pargs {
 public:


  virtual ~ReplicaService_get_pargs() noexcept;
  const std::string* key;
  const std::string* clientIdentifier;
  const int32_t* requestIdentifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_get_result__isset {
  _ReplicaService_get_result__isset() : success(false) {}
  bool success :1;
} _ReplicaService_get_result__isset;

class ReplicaService_get_result {
 public:

  ReplicaService_get_result(const ReplicaService_get_result&);
  ReplicaService_get_result& operator=(const ReplicaService_get_result&);
  ReplicaService_get_result() {
  }

  virtual ~ReplicaService_get_result() noexcept;
  GetResponse success;

  _ReplicaService_get_result__isset __isset;

  void __set_success(const GetResponse& val);

  bool operator == (const ReplicaService_get_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ReplicaService_get_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_get_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_get_presult__isset {
  _ReplicaService_get_presult__isset() : success(false) {}
  bool success :1;
} _ReplicaService_get_presult__isset;

class ReplicaService_get_presult {
 public:


  virtual ~ReplicaService_get_presult() noexcept;
  GetResponse* success;

  _ReplicaService_get_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ReplicaService_put_args__isset {
  _ReplicaService_put_args__isset() : key(false), value(false), clientIdentifier(false), requestIdentifier(false) {}
  bool key :1;
  bool value :1;
  bool clientIdentifier :1;
  bool requestIdentifier :1;
} _ReplicaService_put_args__isset;

class ReplicaService_put_args {
 public:

  ReplicaService_put_args(const ReplicaService_put_args&);
  ReplicaService_put_args& operator=(const ReplicaService_put_args&);
  ReplicaService_put_args() : key(), value(), clientIdentifier(), requestIdentifier(0) {
  }

  virtual ~ReplicaService_put_args() noexcept;
  std::string key;
  std::string value;
  std::string clientIdentifier;
  int32_t requestIdentifier;

  _ReplicaService_put_args__isset __isset;

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  void __set_clientIdentifier(const std::string& val);

  void __set_requestIdentifier(const int32_t val);

  bool operator == (const ReplicaService_put_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(clientIdentifier == rhs.clientIdentifier))
      return false;
    if (!(requestIdentifier == rhs.requestIdentifier))
      return false;
    return true;
  }
  bool operator != (const ReplicaService_put_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_put_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ReplicaService_put_pargs {
 public:


  virtual ~ReplicaService_put_pargs() noexcept;
  const std::string* key;
  const std::string* value;
  const std::string* clientIdentifier;
  const int32_t* requestIdentifier;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_put_result__isset {
  _ReplicaService_put_result__isset() : success(false) {}
  bool success :1;
} _ReplicaService_put_result__isset;

class ReplicaService_put_result {
 public:

  ReplicaService_put_result(const ReplicaService_put_result&);
  ReplicaService_put_result& operator=(const ReplicaService_put_result&);
  ReplicaService_put_result() {
  }

  virtual ~ReplicaService_put_result() noexcept;
  PutResponse success;

  _ReplicaService_put_result__isset __isset;

  void __set_success(const PutResponse& val);

  bool operator == (const ReplicaService_put_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ReplicaService_put_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_put_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_put_presult__isset {
  _ReplicaService_put_presult__isset() : success(false) {}
  bool success :1;
} _ReplicaService_put_presult__isset;

class ReplicaService_put_presult {
 public:


  virtual ~ReplicaService_put_presult() noexcept;
  PutResponse* success;

  _ReplicaService_put_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class ReplicaService_kill_args {
 public:

  ReplicaService_kill_args(const ReplicaService_kill_args&);
  ReplicaService_kill_args& operator=(const ReplicaService_kill_args&);
  ReplicaService_kill_args() {
  }

  virtual ~ReplicaService_kill_args() noexcept;

  bool operator == (const ReplicaService_kill_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ReplicaService_kill_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_kill_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ReplicaService_kill_pargs {
 public:


  virtual ~ReplicaService_kill_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ReplicaService_getInformation_args {
 public:

  ReplicaService_getInformation_args(const ReplicaService_getInformation_args&);
  ReplicaService_getInformation_args& operator=(const ReplicaService_getInformation_args&);
  ReplicaService_getInformation_args() {
  }

  virtual ~ReplicaService_getInformation_args() noexcept;

  bool operator == (const ReplicaService_getInformation_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ReplicaService_getInformation_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_getInformation_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ReplicaService_getInformation_pargs {
 public:


  virtual ~ReplicaService_getInformation_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_getInformation_result__isset {
  _ReplicaService_getInformation_result__isset() : success(false) {}
  bool success :1;
} _ReplicaService_getInformation_result__isset;

class ReplicaService_getInformation_result {
 public:

  ReplicaService_getInformation_result(const ReplicaService_getInformation_result&);
  ReplicaService_getInformation_result& operator=(const ReplicaService_getInformation_result&);
  ReplicaService_getInformation_result() {
  }

  virtual ~ReplicaService_getInformation_result() noexcept;
  std::map<std::string, std::string>  success;

  _ReplicaService_getInformation_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val);

  bool operator == (const ReplicaService_getInformation_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ReplicaService_getInformation_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_getInformation_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ReplicaService_getInformation_presult__isset {
  _ReplicaService_getInformation_presult__isset() : success(false) {}
  bool success :1;
} _ReplicaService_getInformation_presult__isset;

class ReplicaService_getInformation_presult {
 public:


  virtual ~ReplicaService_getInformation_presult() noexcept;
  std::map<std::string, std::string> * success;

  _ReplicaService_getInformation_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class ReplicaService_start_args {
 public:

  ReplicaService_start_args(const ReplicaService_start_args&);
  ReplicaService_start_args& operator=(const ReplicaService_start_args&);
  ReplicaService_start_args() {
  }

  virtual ~ReplicaService_start_args() noexcept;

  bool operator == (const ReplicaService_start_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ReplicaService_start_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicaService_start_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ReplicaService_start_pargs {
 public:


  virtual ~ReplicaService_start_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class ReplicaServiceClient : virtual public ReplicaServiceIf {
 public:
  ReplicaServiceClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ReplicaServiceClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void requestVote(Ballot& _return, const int32_t term, const ID& candidateID, const int32_t lastLogIndex, const int32_t lastLogTerm);
  void send_requestVote(const int32_t term, const ID& candidateID, const int32_t lastLogIndex, const int32_t lastLogTerm);
  void recv_requestVote(Ballot& _return);
  void appendEntry(AppendEntryResponse& _return, const int32_t term, const ID& leaderID, const int32_t prevLogIndex, const int32_t prevLogTerm, const Entry& entry, const int32_t leaderCommit);
  void send_appendEntry(const int32_t term, const ID& leaderID, const int32_t prevLogIndex, const int32_t prevLogTerm, const Entry& entry, const int32_t leaderCommit);
  void recv_appendEntry(AppendEntryResponse& _return);
  void get(GetResponse& _return, const std::string& key, const std::string& clientIdentifier, const int32_t requestIdentifier);
  void send_get(const std::string& key, const std::string& clientIdentifier, const int32_t requestIdentifier);
  void recv_get(GetResponse& _return);
  void put(PutResponse& _return, const std::string& key, const std::string& value, const std::string& clientIdentifier, const int32_t requestIdentifier);
  void send_put(const std::string& key, const std::string& value, const std::string& clientIdentifier, const int32_t requestIdentifier);
  void recv_put(PutResponse& _return);
  void kill();
  void send_kill();
  void getInformation(std::map<std::string, std::string> & _return);
  void send_getInformation();
  void recv_getInformation(std::map<std::string, std::string> & _return);
  void start();
  void send_start();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ReplicaServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<ReplicaServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (ReplicaServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_requestVote(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_appendEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_put(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_kill(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getInformation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_start(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ReplicaServiceProcessor(::std::shared_ptr<ReplicaServiceIf> iface) :
    iface_(iface) {
    processMap_["requestVote"] = &ReplicaServiceProcessor::process_requestVote;
    processMap_["appendEntry"] = &ReplicaServiceProcessor::process_appendEntry;
    processMap_["get"] = &ReplicaServiceProcessor::process_get;
    processMap_["put"] = &ReplicaServiceProcessor::process_put;
    processMap_["kill"] = &ReplicaServiceProcessor::process_kill;
    processMap_["getInformation"] = &ReplicaServiceProcessor::process_getInformation;
    processMap_["start"] = &ReplicaServiceProcessor::process_start;
  }

  virtual ~ReplicaServiceProcessor() {}
};

class ReplicaServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ReplicaServiceProcessorFactory(const ::std::shared_ptr< ReplicaServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::std::shared_ptr< ReplicaServiceIfFactory > handlerFactory_;
};

class ReplicaServiceMultiface : virtual public ReplicaServiceIf {
 public:
  ReplicaServiceMultiface(std::vector<std::shared_ptr<ReplicaServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ReplicaServiceMultiface() {}
 protected:
  std::vector<std::shared_ptr<ReplicaServiceIf> > ifaces_;
  ReplicaServiceMultiface() {}
  void add(::std::shared_ptr<ReplicaServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void requestVote(Ballot& _return, const int32_t term, const ID& candidateID, const int32_t lastLogIndex, const int32_t lastLogTerm) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->requestVote(_return, term, candidateID, lastLogIndex, lastLogTerm);
    }
    ifaces_[i]->requestVote(_return, term, candidateID, lastLogIndex, lastLogTerm);
    return;
  }

  void appendEntry(AppendEntryResponse& _return, const int32_t term, const ID& leaderID, const int32_t prevLogIndex, const int32_t prevLogTerm, const Entry& entry, const int32_t leaderCommit) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->appendEntry(_return, term, leaderID, prevLogIndex, prevLogTerm, entry, leaderCommit);
    }
    ifaces_[i]->appendEntry(_return, term, leaderID, prevLogIndex, prevLogTerm, entry, leaderCommit);
    return;
  }

  void get(GetResponse& _return, const std::string& key, const std::string& clientIdentifier, const int32_t requestIdentifier) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get(_return, key, clientIdentifier, requestIdentifier);
    }
    ifaces_[i]->get(_return, key, clientIdentifier, requestIdentifier);
    return;
  }

  void put(PutResponse& _return, const std::string& key, const std::string& value, const std::string& clientIdentifier, const int32_t requestIdentifier) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->put(_return, key, value, clientIdentifier, requestIdentifier);
    }
    ifaces_[i]->put(_return, key, value, clientIdentifier, requestIdentifier);
    return;
  }

  void kill() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->kill();
    }
    ifaces_[i]->kill();
  }

  void getInformation(std::map<std::string, std::string> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getInformation(_return);
    }
    ifaces_[i]->getInformation(_return);
    return;
  }

  void start() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->start();
    }
    ifaces_[i]->start();
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class ReplicaServiceConcurrentClient : virtual public ReplicaServiceIf {
 public:
  ReplicaServiceConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  ReplicaServiceConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void requestVote(Ballot& _return, const int32_t term, const ID& candidateID, const int32_t lastLogIndex, const int32_t lastLogTerm);
  int32_t send_requestVote(const int32_t term, const ID& candidateID, const int32_t lastLogIndex, const int32_t lastLogTerm);
  void recv_requestVote(Ballot& _return, const int32_t seqid);
  void appendEntry(AppendEntryResponse& _return, const int32_t term, const ID& leaderID, const int32_t prevLogIndex, const int32_t prevLogTerm, const Entry& entry, const int32_t leaderCommit);
  int32_t send_appendEntry(const int32_t term, const ID& leaderID, const int32_t prevLogIndex, const int32_t prevLogTerm, const Entry& entry, const int32_t leaderCommit);
  void recv_appendEntry(AppendEntryResponse& _return, const int32_t seqid);
  void get(GetResponse& _return, const std::string& key, const std::string& clientIdentifier, const int32_t requestIdentifier);
  int32_t send_get(const std::string& key, const std::string& clientIdentifier, const int32_t requestIdentifier);
  void recv_get(GetResponse& _return, const int32_t seqid);
  void put(PutResponse& _return, const std::string& key, const std::string& value, const std::string& clientIdentifier, const int32_t requestIdentifier);
  int32_t send_put(const std::string& key, const std::string& value, const std::string& clientIdentifier, const int32_t requestIdentifier);
  void recv_put(PutResponse& _return, const int32_t seqid);
  void kill();
  void send_kill();
  void getInformation(std::map<std::string, std::string> & _return);
  int32_t send_getInformation();
  void recv_getInformation(std::map<std::string, std::string> & _return, const int32_t seqid);
  void start();
  void send_start();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif



#endif
