#!/usr/bin/python3

import argparse
from sys import argv, exit, path
from os import getenv, path as ospath
from random import randrange, seed, choice
import logging
from socket import gethostname, gethostbyname, timeout
from time import sleep
import traceback

path.append('external-projs/gen-py')

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer
from dotenv import load_dotenv

REQUEST_IDENTIFIER_ENV_VAR_NAME = "REQUEST_ID_FILE"
RPC_TIMEOUT_ENV_VAR_NAME = "CMD_LINE_TOOL_TIMEOUT_MS"
NUM_REQUEST_RETRIES_ENV_VAR_NAME = "CMD_LINE_TOTAL_NUM_RETRIES_PER_REQUEST"
REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME = "CMD_LINE_TOOL_REST_PERIOD_BETWEEN_CALLS_MS"
NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME = "CMD_LINE_TOOL_NUM_REQUEST_RETRY_CYCLES_BEFORE_QUITTING"

from replicaservice import ReplicaService, ttypes

logger = logging.getLogger(f'{argv[0]}_logger')
handler = logging.FileHandler(f'{argv[0]}.log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)

class PutFailureException(Exception):
    pass

class GetFailureException(Exception):
    pass

class DelFailureException(Exception):
    pass

class ConfigurationInstallationException(Exception):
    pass

class NoTargetFoundException(Exception):
    pass

class InformationRetrievalFailureException(Exception):
    pass

ttypes.ID.__hash__ = lambda self: hash((self.hostname, self.port))


def isNullID(id):
    return (not id.hostname) and id.port == 0


def getSocketAddr(socketAddrStr):
    if ':' not in socketAddrStr or socketAddrStr.count(':') != 1:
        print(f'{socketAddrStr}: Invalid format (should be <host>:<port>)')
        raise ValueError()

    host, portStr = tuple(socketAddrStr.strip().split(':'))
    port = int(portStr)

    return (host, port)


def killReplica(url):
    host, port = getSocketAddr(url)

    transport = TSocket.TSocket(host, port)
    transport = TTransport.TBufferedTransport(transport)

    try:
        transport.open()

        protocol = TBinaryProtocol.TBinaryProtocol(transport)
        client = ReplicaService.Client(protocol)

        try:
            client.kill()

        except TTransport.TTransportException as e:
            logger.debug(f'Experienced error while attempting to kill replica at ({host}:{port})')

    except TTransport.TTransportException as e:
        logger.debug(f'Experienced error while setting up connection to attempt to kill replica at ({host}:{port})')


def listClusterMembers(isTableUsed, clustermembership):
    clusterInfo = {}

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    host, port = choice(clustermembership)

    for cycleNum in range(numCyclesBeforeQuitting):
        logger.debug(f'Now entering cycle {cycleNum} for MEMBERS request')
        for retryNum in range(numRetriesBeforeChangingRequestID):
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()
                protocol = TBinaryProtocol.TBinaryProtocol(transport)
                client = ReplicaService.Client(protocol)

                logger.debug(f'Now contacting ({host}:{port}) to resolve MEMBERS')

                try:
                    informationResponse = client.getInformation()

                    if informationResponse.success:
                        logger.debug(f'MEMBERS request successfully resolved')

                        displayClusterInfoInTable(informationResponse.clusterInformation) if isTableUsed else displayClusterInfoWithCommaSep(informationResponse.clusterInformation)

                        return

                    elif isNullID(informationResponse.leaderID):
                        logger.debug(f'MEMBERS request unsuccessful and current leader is unknown')
                        host, port = choice(clustermembership)
                    else:
                        logger.debug(f'MEMBERS request unsuccessful')
                        host = informationResponse.leaderID.hostname
                        port = informationResponse.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced transport error while contacting ({host}:{port}): {str(e)}')
                host, port = choice(clustermembership)

            sleep((pauseDurationAfterRetryMS / 1000) * 2)

    raise InformationRetrievalFailureException()


def displayClusterInfoInTable(clusterInfo):
    print("+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+")
    print(f'|{"Endpoint".center(23)}|{"Role".center(23)}|{"Term".center(23)}|{"Index".center(23)}|')
    print("+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+")

    for endpoint, replicaInformation in clusterInfo.items():
        endpointStr = f'http://{endpoint.hostname}:{endpoint.port}'.center(23)

        if replicaInformation:
            print(f'|{endpointStr}|{replicaInformation["role"].center(23)}|{replicaInformation["term"].center(23)}|{replicaInformation["index"].center(23)}|')
        else:
            print(f'|{endpointStr}|{"N/A".center(23)}|{"N/A".center(23)}|{"N/A".center(23)}|')

    print("+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+")


def displayClusterInfoWithCommaSep(clusterInfo):
    count = 0
    for endpoint, replicaInformation in clusterInfo.items():
        if replicaInformation:
            print(f'{endpoint.hostname},{endpoint.port},{replicaInformation["role"]},{replicaInformation["term"]},{replicaInformation["index"]}', end='')
        else:
            print(f'{endpoint.hostname},{endpoint.port},None', end='')

        if count < len(clusterInfo)-1:
            print(';', end='')

        count += 1

    print()


def delKey(key, clustermembership):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())

    return delKeyHelper(key, hostIP, nextRequestIdentifier, clustermembership)

 
def delKeyHelper(key, clientIdentifier, requestNumber, clustermembership):

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    currentRequestNumber = requestNumber
    host, port = choice(clustermembership)

    for cycleNum in range(numCyclesBeforeQuitting):
        logger.debug(f'Now entering cycle {cycleNum} for DEL request')
        for retryNum in range(numRetriesBeforeChangingRequestID):
            logger.debug(f'Request Identifier {currentRequestNumber} being used for DEL attempt {retryNum}')
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()
                protocol = TBinaryProtocol.TBinaryProtocol(transport)
                client = ReplicaService.Client(protocol)

                logger.debug(f'Now contacting ({host}:{port}) to resolve DEL')

                try:
                    response = client.deletekey(str(key), clientIdentifier, currentRequestNumber)

                    if response.success:
                        logger.debug(f'DEL request successfully resolved')
                        setNextRequestIdentifier(currentRequestNumber + 1)

                        return True

                    elif isNullID(response.leaderID):
                        logger.debug(f'DEL request unsuccessful and current leader is unknown')
                        host, port = choice(clustermembership)
                    else:
                        logger.debug(f'DEL request unsuccessful')
                        host = response.leaderID.hostname
                        port = response.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced transport error while contacting ({host}:{port}): {str(e)}')
                host, port = choice(clustermembership)

            sleep((pauseDurationAfterRetryMS / 1000) * 2)

        currentRequestNumber += 1

    raise DelFailureException()


def get(key, numPastMappings, clustermembership):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())

    return getHelper(key, hostIP, nextRequestIdentifier, numPastMappings, clustermembership)


def getHelper(key, clientIdentifier, requestNumber, numPastMappings, clustermembership):

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    currentRequestNumber = requestNumber
    host, port = choice(clustermembership)

    for cycleNum in range(numCyclesBeforeQuitting):
        for retryNum in range(numRetriesBeforeChangingRequestID):
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()
                try:
                    protocol = TBinaryProtocol.TBinaryProtocol(transport)
                    client = ReplicaService.Client(protocol)

                    logger.debug(f'Now contacting ({host}:{port}) to resolve GET')

                    response = client.get(str(key), clientIdentifier, currentRequestNumber, numPastMappings)

                    if response.success:
                        logger.debug(f'GET request successfully resolved: {response.values} is the value retreived')
                        setNextRequestIdentifier(currentRequestNumber + 1)

                        return response.values

                    elif isNullID(response.leaderID):
                        logger.debug(f'GET request unsuccessful and current leader is unknown')
                        host, port = choice(clustermembership)
                    else:
                        logger.debug(f'GET request unsuccessful')
                        host = response.leaderID.hostname
                        port = response.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced error while creating connection to contact ({host}:{port}) to resolve GET')
                host, port = choice(clustermembership)

            sleep(pauseDurationAfterRetryMS / 1000)

        currentRequestNumber += 1

    raise GetFailureException()


def put(key, value, clustermembership):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())

    return putHelper(key, value, hostIP, nextRequestIdentifier, clustermembership)


def putHelper(key, value, clientIdentifier, requestNumber, clustermembership):

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    currentRequestNumber = requestNumber
    host, port = choice(clustermembership)

    for cycleNum in range(numCyclesBeforeQuitting):
        logger.debug(f'Now entering cycle {cycleNum} for PUT request')
        for retryNum in range(numRetriesBeforeChangingRequestID):
            logger.debug(f'Request Identifier {currentRequestNumber} being used for PUT attempt {retryNum}')
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()
                protocol = TBinaryProtocol.TBinaryProtocol(transport)
                client = ReplicaService.Client(protocol)

                logger.debug(f'Now contacting ({host}:{port}) to resolve PUT')

                try:
                    response = client.put(str(key), str(value), clientIdentifier, currentRequestNumber)

                    if response.success:
                        logger.debug(f'PUT request successfully resolved: {key} => {value}')
                        setNextRequestIdentifier(currentRequestNumber + 1)

                        return True

                    elif isNullID(response.leaderID):
                        logger.debug(f'PUT request unsuccessful and current leader is unknown')
                        host, port = getRandomReplica()
                    else:
                        logger.debug(f'PUT request unsuccessful')
                        host = response.leaderID.hostname
                        port = response.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced transport error while contacting ({host}:{port}): {str(e)}')
                host, port = getRandomReplica()

            sleep((pauseDurationAfterRetryMS / 1000) * 2)

        currentRequestNumber += 1

    raise PutFailureException()


def addNewConfiguration(newSocketAddrLst, clustermembership):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())
    ids = list(map(lambda sockAddr : ttypes.ID(hostname = sockAddr[:sockAddr.index(':')], port = int(sockAddr[sockAddr.index(':')+1:])), newSocketAddrLst))
    return addNewConfigurationHelper(ids, hostIP, nextRequestIdentifier, clustermembership)


def addNewConfigurationHelper(newSocketAddrLst, clientIdentifier, requestNumber, clustermembership):

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    currentRequestNumber = requestNumber
    host, port = choice(clustermembership)

    for cycleNum in range(numCyclesBeforeQuitting):
        logger.debug(f'Now entering cycle {cycleNum} for NEWCONFIG request')
        print("looping")
        for retryNum in range(numRetriesBeforeChangingRequestID):
            print("looping inner")
            logger.debug(f'Request Identifier {currentRequestNumber} being used for NEWCONFIG attempt {retryNum}')
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()
                protocol = TBinaryProtocol.TBinaryProtocol(transport)
                client = ReplicaService.Client(protocol)

                logger.debug(f'Now contacting ({host}:{port}) to resolve NEWCONFIG')

                try:
                    response = client.addNewConfiguration(newSocketAddrLst, clientIdentifier, currentRequestNumber)

                    if response.success:
                        logger.debug(f'NEWCONFIG request successfully resolved')
                        setNextRequestIdentifier(currentRequestNumber + 1)

                        return True

                    elif isNullID(response.leaderID):
                        logger.debug(f'NEWCONFIG request unsuccessful and current leader is unknown')
                        host, port = choice(clustermembership)
                    else:
                        logger.debug(f'NEWCONFIG request unsuccessful')
                        host = response.leaderID.hostname
                        port = response.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced transport error while contacting ({host}:{port}): {str(e)}')
                host, port = getRandomReplica()

            print("now sleeping")
            sleep((pauseDurationAfterRetryMS / 1000) * 2)

        currentRequestNumber += 1

    raise ConfigurationInstallationException()


def getNextRequestIdentifier():
    if not ospath.exists(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME)):
        with open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME), 'w') as nextIdentifierFileObj:
            nextIdentifierFileObj.write("0")

    with open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME)) as nextIdentifierFileObj:
        nextIdentifierStr = nextIdentifierFileObj.read().strip()
        return int(nextIdentifierStr)


def setNextRequestIdentifier(nextIdentifier):
    with open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME), 'w') as nextIdentifierFileObj:
        nextIdentifierStr = str(nextIdentifier)
        nextIdentifierFileObj.write(nextIdentifierStr)


if __name__ == "__main__":

    load_dotenv()

    parser = argparse.ArgumentParser(prog=f'{argv[0]}')
    subparsers = parser.add_subparsers(help="sub-command help", dest="command")

    killParser = subparsers.add_parser("kill", help="Used to stop a running replica")
    killParser.add_argument("url", help="<host>:<port>")

    membersParser = subparsers.add_parser("members", help="Used to list state of current cluster members")
    membersParser.add_argument("clustermembership", nargs="+", help="IP address / port number pairs for cluster members.  Should have the form <ip addr>:<port number>.")
    membersParser.add_argument("-table", action="store_true")

    putParser = subparsers.add_parser("put", help="Used to create or update a key-value pair")
    putParser.add_argument("key", help="To be used as a key for the mapping")
    putParser.add_argument("value", help="To be used as a value for the mapping")
    putParser.add_argument("clustermembership", nargs="+", help="IP address / port number pairs for cluster members.  Should have the form <ip addr>:<port number>.")

    getParser = subparsers.add_parser("get", help="Used to read value associated with a given key")
    getParser.add_argument("key", help="Key whose associated value will be retreived")
    getParser.add_argument("clustermembership", nargs="+", help="IP address / port number pairs for cluster members.  Should have the form <ip addr>:<port number>.")
    getParser.add_argument("-rev", nargs="?", type=int, default=0)

    delKeyParser = subparsers.add_parser("del", help="Used to remove a given key from the cluster")
    delKeyParser.add_argument("key", help="Key to be removed from the cluster")
    delKeyParser.add_argument("clustermembership", nargs="+", help="IP address / port number pairs for cluster members.  Should have the form <ip addr>:<port number>.")

    newConfigParser = subparsers.add_parser("newconfig", help="Used to change the configuration of the cluster")
    newConfigParser.add_argument("newclustermembership", nargs="+", help="IP address / port number pairs for machines included in the new cluster configuration.  Should have the form <ip addr>:<port number>.")
    newConfigParser.add_argument("clustermembership", nargs="+", help="IP address / port number pairs for cluster members.  Should have the form <ip addr>:<port number>.")

    args = parser.parse_args()

    clustermembership = []
    if args.clustermembership:
      clustermembership = [getSocketAddr(member) for member in args.clustermembership]

    if args.command == "kill":
        killReplica(args.url)
    elif args.command == "members":
        try:
            listClusterMembers(args.table, clustermembership)
        except InformationRetrievalFailureException:
            print("MEMBERS Request Failed")
    elif args.command == "put":
        try:
            print(put(args.key, args.value, clustermembership))
        except PutFailureException:
            print("PUT Request Failed")
    elif args.command == "get":
        try:
            for val in get(args.key, args.rev, clustermembership):
                print(val)
        except GetFailureException:
            print("GET Request Failed")
    elif args.command == "newconfig":
        try:
            print(addNewConfiguration(args.socketaddresses, clustermembership))
        except ConfigurationInstallationException:
            print("Configuration Installation Failed")
    else:
        parser.error("No command provided: must be one of (kill, members, put, get, newconfig)")
