#!/usr/bin/python3

import argparse
from sys import argv, exit, path
from os import getenv
from random import randrange, seed
import logging
from socket import gethostname, gethostbyname, timeout

path.append('gen-py')

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer
from dotenv import load_dotenv

REQUEST_IDENTIFIER_ENV_VAR_NAME = "REQUEST_ID_FILE"
MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME = "CURRENT_LEADER_INFO_FILE"
RPC_TIMEOUT_ENV_VAR_NAME = "RPC_TIMEOUT_MS"

from replicaservice import ReplicaService

logger = logging.getLogger(f'{argv[0]}_logger')
handler = logging.FileHandler(f'{argv[0]}.log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)

def killReplica(url):
    if ':' not in url or list(url).count(':') != 1:
        print(f'Cannot kill replica at {url}: Invalid format (should be <host>:<port>)')
        exit(1)

    host, portStr = tuple(url.split(':'))
    port = int(portStr)

    transport = TSocket.TSocket(host, port)
    transport = TTransport.TBufferedTransport(transport)
    transport.open()
    protocol = TBinaryProtocol.TBinaryProtocol(transport)
    client = ReplicaService.Client(protocol)

    client.kill()

def listClusterMembers(isTableUsed):
    print(f'Displaying cluster members; tableused={isTableUsed}')

def get(key):
    nextRequestIdentifier = getNextRequestIdentifier()
    ret = getHelper(key, nextRequestIdentifier)
    #setNextRequestIdentifier(nextRequestIdentifier + 1)
    return ret

def getHelper(key, requestNumber):
    leaderInfo = getLeaderInfo()
    if not leaderInfo:
        leaderInfo = getRandomReplica()

    host, port = leaderInfo

    while True:
        transport = TSocket.TSocket(host, port)
        transport = TTransport.TBufferedTransport(transport)
        try:
            transport.open()
            protocol = TBinaryProtocol.TBinaryProtocol(transport)
            client = ReplicaService.Client(protocol)

            logger.debug(f'Now contacting ({host}:{port}) to resolve GET')

            response = client.get(str(key), requestNumber)

            if response.success:
                logger.debug(f'GET request successfully resolved: {response.value} is the value retreived')
                open(getenv(MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME), 'w').write(f'{host}:{port}')

                return response.value

            elif not response.leaderID:
                host, port = getRandomReplica()
            else:
                host = response.leaderID.hostname
                port = response.leaderID.port

        except TTransport.TTransportException:
            logger.debug(f'Experienced error while contacting ({host}:{port})')
            host, port = getRandomReplica()

def put(key, value):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())
    ret = putHelper(key, value, hostIP, nextRequestIdentifier)
    #setNextRequestIdentifier(nextRequestIdentifier + 1)
    return ret

def putHelper(key, value, clientIdentifier, requestNumber):
    leaderInfo = getLeaderInfo()
    if not leaderInfo:
        leaderInfo = getRandomReplica()

    host, port = leaderInfo

    while True:
        transport = TSocket.TSocket(host, port)
        transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
        transport = TTransport.TBufferedTransport(transport)

        try:
            transport.open()
            protocol = TBinaryProtocol.TBinaryProtocol(transport)
            client = ReplicaService.Client(protocol)

            logger.debug(f'Now contacting ({host}:{port}) to resolve PUT')

            response = client.put(str(key), str(value), clientIdentifier, requestNumber)

            if response.success:
                logger.debug(f'PUT request successfully resolved: {key} => {value}')
                open(getenv(MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME), 'w').write(f'{host}:{port}')

                return True

            elif not response.leaderID:
                host, port = getRandomReplica()
            else:
                host = response.leaderID.hostname
                port = response.leaderID.port

        except TTransport.TTransportException:
            logger.debug(f'Experienced transport error while contacting ({host}:{port})')
            host, port = getRandomReplica()
        except timeout:
            logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

def getLeaderInfo():
    leaderInfoFileObj = open(getenv("CURRENT_LEADER_INFO_FILE"), 'r')
    leaderAddr = leaderInfoFileObj.read().strip()
    if not leaderAddr:
        return ()
    if ':' not in leaderAddr or list(leaderAddr).count(':') > 1:
        raise ValueError(f'{getenv("CURRENT_LEADER_INFO_FILE")} containing leader information is ill-formed: should have single line of the form <host>:<port>; {leaderAddr} does not comply.')

    return tuple(leaderAddr.split(':'))

def getRandomReplica():
    seed()

    replicaInfoFileObj = open(getenv("CLUSTER_MEMBERSHIP_FILE"), 'r')

    replicaInfo = []

    line = replicaInfoFileObj.readline()
    while line:
        line = line.strip()
        if not line:
            raise ValueError(f'{getenv("CLUSTER_MEMBERSHIP_FILE")} is ill-formed: each line shoudl be of the form <host>:<port>; {line} does not comply.')
        if ':' not in line or list(line).count(':') > 1:
            raise ValueError(f'{getenv("CLUSTER_MEMBERSHIP_FILE")} is ill-formed: the file must not be empty')

        host, portStr = tuple(line.strip().split(':'))
        port = int(portStr)

        replicaInfo.append((host, port))

        line = replicaInfoFileObj.readline()

    return replicaInfo[randrange(len(replicaInfo))]

def getNextRequestIdentifier():
    nextIdentifierFileObj = open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME))
    nextIdentifierStr = nextIdentifierFileObj.read().strip()

    return int(nextIdentifierStr)

def setNextRequestIdentifier(nextIdentifier):
    nextIdentifierFileObj = open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME), 'w')
    nextIdentifierStr = str(nextIdentifier + 1)
    nextIdentifierFileObj.write(nextIdentifierStr)

if __name__ == "__main__":
    load_dotenv()

    parser = argparse.ArgumentParser(prog=f'{argv[0]}')
    subparsers = parser.add_subparsers(help="sub-command help", dest="command")

    killParser = subparsers.add_parser("kill", help="Used to stop a running replica")
    killParser.add_argument("url", help="<host>:<port>")

    membersParser = subparsers.add_parser("members", help="Used to list state of current cluster members")
    membersParser.add_argument("-table", action="store_true")

    putParser = subparsers.add_parser("put", help="Used to create or update a key-value pair")
    putParser.add_argument("key", help="To be used as a key for the mapping")
    putParser.add_argument("value", help="To be used as a value for the mapping")

    getParser = subparsers.add_parser("get", help="Used to read value associated with a given key")
    getParser.add_argument("key", help="Key whose associated value will be retreived")

    args = parser.parse_args()

    if args.command == "kill":
        killReplica(args.url)
    elif args.command == "members":
        listClusterMembers(args.table)
    elif args.command == "put":
        print(put(args.key, args.value))
    elif args.command == "get":
        print(get(args.key))
    else:
        parser.error("No command provided: must be one of (kill, members, put, get)")
