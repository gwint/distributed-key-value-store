#!/usr/bin/python3

import argparse
from sys import argv, exit, path
from os import getenv
from random import randrange, seed
import logging
from socket import gethostname, gethostbyname, timeout
from time import sleep
import traceback

path.append('gen-py')

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer
from dotenv import load_dotenv

REQUEST_IDENTIFIER_ENV_VAR_NAME = "REQUEST_ID_FILE"
MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME = "CURRENT_LEADER_INFO_FILE"
RPC_TIMEOUT_ENV_VAR_NAME = "CMD_LINE_TOOL_TIMEOUT_MS"
NUM_REQUEST_RETRIES_ENV_VAR_NAME = "CMD_LINE_TOTAL_NUM_RETRIES_PER_REQUEST"
REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME = "CMD_LINE_TOOL_REST_PERIOD_BETWEEN_CALLS_MS"
NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME = "CMD_LINE_TOOL_NUM_REQUEST_RETRY_CYCLES_BEFORE_QUITTING"
CLUSTER_MEMBERSHIP_FILE_NAME_ENV_VAR_NAME = "CLUSTER_MEMBERSHIP_FILE"

from replicaservice import ReplicaService

logger = logging.getLogger(f'{argv[0]}_logger')
handler = logging.FileHandler(f'{argv[0]}.log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)

class PutFailureException(Exception):
    pass

class GetFailureException(Exception):
    pass

def killReplica(url):
    if ':' not in url or list(url).count(':') != 1:
        print(f'Cannot kill replica at {url}: Invalid format (should be <host>:<port>)')
        exit(1)

    host, portStr = tuple(url.split(':'))
    port = int(portStr)

    transport = TSocket.TSocket(host, port)
    transport = TTransport.TBufferedTransport(transport)
    transport.open()
    protocol = TBinaryProtocol.TBinaryProtocol(transport)
    client = ReplicaService.Client(protocol)

    client.kill()

def listClusterMembers(isTableUsed):
    print(f'Displaying cluster members; tableused={isTableUsed}')
    clusterInfo = {}

    with open(getenv(CLUSTER_MEMBERSHIP_FILE_NAME_ENV_VAR_NAME)) as membershipFileObj:
        line = membershipFileObj.readline()
        while line:
            host, port = tuple(line.split(':'))

            transport = TSocket.TSocket(host, int(port))
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()

                try:
                    protocol = TBinaryProtocol.TBinaryProtocol(transport)
                    client = ReplicaService.Client(protocol)
                    clusterInfo[(host,int(port))] = client.getInformation()

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while attempting to gather information from ({host}:{port})')
                    else:
                        logger.debug(f'Experienced a non-timeout error while attempting to gather information from ({host}:{port}): {str(e)}')

                    clusterInfo[(host, int(port))] = None

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced error while setting up connection to attempt to gather information from ({host}:{port})')
                clusterInfo[(host, int(port))] = None

            line = membershipFileObj.readline()

    displayClusterInfoInTable(clusterInfo) if isTableUsed else displayClusterInfoWithCommaSep(clusterInfo)

def displayClusterInfoInTable(clusterInfo):
    pass

def displayClusterInfoWithCommaSep(clusterInfo):
    for endpoint, replicaInformation in clusterInfo.items():
        if replicaInformation:
            print(f'{endpoint[0]},{endpoint[1]},{replicaInformation["role"]},{replicaInformation["term"]},{replicaInformation["index"]};', end='')
        else:
            print(f'{endpoint[0]},{endpoint[1]},None;', end='')

    print()

def get(key):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())
    ret = getHelper(key, hostIP, nextRequestIdentifier)

    return ret

def getHelper(key, clientIdentifier, requestNumber):
    leaderInfo = getLeaderInfo()
    if not leaderInfo:
        leaderInfo = getRandomReplica()

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    currentRequestNumber = requestNumber
    host, port = leaderInfo

    for cycleNum in range(numCyclesBeforeQuitting):
        for retryNum in range(numRetriesBeforeChangingRequestID):
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)
            try:
                transport.open()
                try:
                    protocol = TBinaryProtocol.TBinaryProtocol(transport)
                    client = ReplicaService.Client(protocol)

                    logger.debug(f'Now contacting ({host}:{port}) to resolve GET')

                    response = client.get(str(key), clientIdentifier, currentRequestNumber)

                    if response.success:
                        logger.debug(f'GET request successfully resolved: {response.value} is the value retreived')
                        open(getenv(MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME), 'w').write(f'{host}:{port}')
                        setNextRequestIdentifier(currentRequestNumber + 1)

                        return response.value

                    elif not response.leaderID:
                        logger.debug(f'GET request unsuccessful and current leader is unknown')
                        host, port = getRandomReplica()
                    else:
                        logger.debug(f'GET request unsuccessful')
                        host = response.leaderID.hostname
                        port = response.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced error while creating connection to contact ({host}:{port}) to resolve GET')
                host, port = getRandomReplica()

            sleep(pauseDurationAfterRetryMS / 1000)

        currentRequestNumber += 1

    raise GetFailureException()

def put(key, value):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())
    ret = putHelper(key, value, hostIP, nextRequestIdentifier)

    return ret

def putHelper(key, value, clientIdentifier, requestNumber):
    leaderInfo = getLeaderInfo()
    if not leaderInfo:
        leaderInfo = getRandomReplica()

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    currentRequestNumber = requestNumber
    host, port = leaderInfo

    for cycleNum in range(numCyclesBeforeQuitting):
        logger.debug(f'Now entering cycle {cycleNum} for PUT request')
        for retryNum in range(numRetriesBeforeChangingRequestID):
            logger.debug(f'Request Identifier {currentRequestNumber} being used for PUT attempt {retryNum}')
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()
                protocol = TBinaryProtocol.TBinaryProtocol(transport)
                client = ReplicaService.Client(protocol)

                logger.debug(f'Now contacting ({host}:{port}) to resolve PUT')

                try:
                    response = client.put(str(key), str(value), clientIdentifier, currentRequestNumber)

                    if response.success:
                        logger.debug(f'PUT request successfully resolved: {key} => {value}')
                        open(getenv(MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME), 'w').write(f'{host}:{port}')
                        setNextRequestIdentifier(currentRequestNumber + 1)

                        return True

                    elif not response.leaderID:
                        logger.debug(f'PUT request unsuccessful and current leader is unknown')
                        host, port = getRandomReplica()
                    else:
                        logger.debug(f'PUT request unsuccessful')
                        host = response.leaderID.hostname
                        port = response.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced transport error while contacting ({host}:{port}): {str(e)}')
                host, port = getRandomReplica()

            sleep((pauseDurationAfterRetryMS / 1000) * 2)

        currentRequestNumber += 1

    raise PutFailureException()

def getLeaderInfo():
    leaderInfoFileObj = open(getenv("CURRENT_LEADER_INFO_FILE"), 'r')
    leaderAddr = leaderInfoFileObj.read().strip()
    if not leaderAddr:
        return ()
    if ':' not in leaderAddr or list(leaderAddr).count(':') > 1:
        raise ValueError(f'{getenv("CURRENT_LEADER_INFO_FILE")} containing leader information is ill-formed: should have single line of the form <host>:<port>; {leaderAddr} does not comply.')

    return tuple(leaderAddr.split(':'))

def getRandomReplica():
    seed()

    replicaInfoFileObj = open(getenv("CLUSTER_MEMBERSHIP_FILE"), 'r')

    replicaInfo = []

    line = replicaInfoFileObj.readline()
    while line:
        line = line.strip()
        if not line:
            raise ValueError(f'{getenv("CLUSTER_MEMBERSHIP_FILE")} is ill-formed: each line shoudl be of the form <host>:<port>; {line} does not comply.')
        if ':' not in line or list(line).count(':') > 1:
            raise ValueError(f'{getenv("CLUSTER_MEMBERSHIP_FILE")} is ill-formed: the file must not be empty')

        host, portStr = tuple(line.strip().split(':'))
        port = int(portStr)

        replicaInfo.append((host, port))

        line = replicaInfoFileObj.readline()

    return replicaInfo[randrange(len(replicaInfo))]

def getNextRequestIdentifier():
    nextIdentifierFileObj = open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME))
    nextIdentifierStr = nextIdentifierFileObj.read().strip()

    return int(nextIdentifierStr)

def setNextRequestIdentifier(nextIdentifier):
    nextIdentifierFileObj = open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME), 'w')
    nextIdentifierStr = str(nextIdentifier)
    nextIdentifierFileObj.write(nextIdentifierStr)

if __name__ == "__main__":
    load_dotenv()

    parser = argparse.ArgumentParser(prog=f'{argv[0]}')
    subparsers = parser.add_subparsers(help="sub-command help", dest="command")

    killParser = subparsers.add_parser("kill", help="Used to stop a running replica")
    killParser.add_argument("url", help="<host>:<port>")

    membersParser = subparsers.add_parser("members", help="Used to list state of current cluster members")
    membersParser.add_argument("-table", action="store_true")

    putParser = subparsers.add_parser("put", help="Used to create or update a key-value pair")
    putParser.add_argument("key", help="To be used as a key for the mapping")
    putParser.add_argument("value", help="To be used as a value for the mapping")

    getParser = subparsers.add_parser("get", help="Used to read value associated with a given key")
    getParser.add_argument("key", help="Key whose associated value will be retreived")

    args = parser.parse_args()

    if args.command == "kill":
        killReplica(args.url)
    elif args.command == "members":
        listClusterMembers(args.table)
    elif args.command == "put":
        try:
            print(put(args.key, args.value))
        except PutFailureException:
            print("PUT Request Failed")
    elif args.command == "get":
        try:
            print(get(args.key))
        except GetFailureException:
            print("GET Request Failed")
    else:
        parser.error("No command provided: must be one of (kill, members, put, get)")
