#!/usr/bin/python3

import argparse
from sys import argv, exit, path
from os import getenv
from random import randrange, seed
import logging
from socket import gethostname, gethostbyname, timeout
from time import sleep
import traceback

path.append('gen-py')

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer
from dotenv import load_dotenv

REQUEST_IDENTIFIER_ENV_VAR_NAME = "REQUEST_ID_FILE"
MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME = "CURRENT_LEADER_INFO_FILE"
RPC_TIMEOUT_ENV_VAR_NAME = "CMD_LINE_TOOL_TIMEOUT_MS"
NUM_REQUEST_RETRIES_ENV_VAR_NAME = "CMD_LINE_TOTAL_NUM_RETRIES_PER_REQUEST"
REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME = "CMD_LINE_TOOL_REST_PERIOD_BETWEEN_CALLS_MS"
NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME = "CMD_LINE_TOOL_NUM_REQUEST_RETRY_CYCLES_BEFORE_QUITTING"

from replicaservice import ReplicaService

logger = logging.getLogger(f'{argv[0]}_logger')
handler = logging.FileHandler(f'{argv[0]}.log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)

class PutFailureException(Exception):
    pass

class GetFailureException(Exception):
    pass

def killReplica(url):
    if ':' not in url or list(url).count(':') != 1:
        print(f'Cannot kill replica at {url}: Invalid format (should be <host>:<port>)')
        exit(1)

    host, portStr = tuple(url.split(':'))
    port = int(portStr)

    transport = TSocket.TSocket(host, port)
    transport = TTransport.TBufferedTransport(transport)
    transport.open()
    protocol = TBinaryProtocol.TBinaryProtocol(transport)
    client = ReplicaService.Client(protocol)

    client.kill()

def listClusterMembers(isTableUsed):
    print(f'Displaying cluster members; tableused={isTableUsed}')

def get(key):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())
    ret = getHelper(key, hostIP, nextRequestIdentifier)

    return ret

def getHelper(key, clientIdentifier, requestNumber):
    leaderInfo = getLeaderInfo()
    if not leaderInfo:
        leaderInfo = getRandomReplica()

    host, port = leaderInfo

    while True:
        transport = TSocket.TSocket(host, port)
        transport = TTransport.TBufferedTransport(transport)
        try:
            transport.open()
            protocol = TBinaryProtocol.TBinaryProtocol(transport)
            client = ReplicaService.Client(protocol)

            logger.debug(f'Now contacting ({host}:{port}) to resolve GET')

            response = client.get(str(key), requestNumber)

            if response.success:
                logger.debug(f'GET request successfully resolved: {response.value} is the value retreived')
                open(getenv(MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME), 'w').write(f'{host}:{port}')

                return response.value

            elif not response.leaderID:
                host, port = getRandomReplica()
            else:
                host = response.leaderID.hostname
                port = response.leaderID.port

        except TTransport.TTransportException as e:
            logger.debug(f'Experienced error while contacting ({host}:{port})')
            host, port = getRandomReplica()

def put(key, value):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())
    ret = putHelper(key, value, hostIP, nextRequestIdentifier)

    return ret

def putHelper(key, value, clientIdentifier, requestNumber):
    leaderInfo = getLeaderInfo()
    if not leaderInfo:
        leaderInfo = getRandomReplica()

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    currentRequestNumber = requestNumber
    host, port = leaderInfo

    for cycleNum in range(numCyclesBeforeQuitting):
        logger.debug(f'Now entering cycle {cycleNum} for PUT request')
        for retryNum in range(numRetriesBeforeChangingRequestID):
            logger.debug(f'Request Identifier {currentRequestNumber} being used for PUT attempt {retryNum}')
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()
                protocol = TBinaryProtocol.TBinaryProtocol(transport)
                client = ReplicaService.Client(protocol)

                logger.debug(f'Now contacting ({host}:{port}) to resolve PUT')

                try:
                    response = client.put(str(key), str(value), clientIdentifier, currentRequestNumber)

                    if response.success:
                        logger.debug(f'PUT request successfully resolved: {key} => {value}')
                        open(getenv(MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME), 'w').write(f'{host}:{port}')
                        setNextRequestIdentifier(currentRequestNumber + 1)

                        return True

                    elif not response.leaderID:
                        logger.debug(f'PUT request unsuccessful and current leader is unknown')
                        host, port = getRandomReplica()
                    else:
                        logger.debug(f'PUT request unsuccessful')
                        host = response.leaderID.hostname
                        port = response.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced transport error while contacting ({host}:{port}): {str(e)}')
                host, port = getRandomReplica()

            sleep(pauseDurationAfterRetryMS / 1000)

        currentRequestNumber += 1

    raise PutFailureException()


def getLeaderInfo():
    leaderInfoFileObj = open(getenv("CURRENT_LEADER_INFO_FILE"), 'r')
    leaderAddr = leaderInfoFileObj.read().strip()
    if not leaderAddr:
        return ()
    if ':' not in leaderAddr or list(leaderAddr).count(':') > 1:
        raise ValueError(f'{getenv("CURRENT_LEADER_INFO_FILE")} containing leader information is ill-formed: should have single line of the form <host>:<port>; {leaderAddr} does not comply.')

    return tuple(leaderAddr.split(':'))

def getRandomReplica():
    seed()

    replicaInfoFileObj = open(getenv("CLUSTER_MEMBERSHIP_FILE"), 'r')

    replicaInfo = []

    line = replicaInfoFileObj.readline()
    while line:
        line = line.strip()
        if not line:
            raise ValueError(f'{getenv("CLUSTER_MEMBERSHIP_FILE")} is ill-formed: each line shoudl be of the form <host>:<port>; {line} does not comply.')
        if ':' not in line or list(line).count(':') > 1:
            raise ValueError(f'{getenv("CLUSTER_MEMBERSHIP_FILE")} is ill-formed: the file must not be empty')

        host, portStr = tuple(line.strip().split(':'))
        port = int(portStr)

        replicaInfo.append((host, port))

        line = replicaInfoFileObj.readline()

    return replicaInfo[randrange(len(replicaInfo))]

def getNextRequestIdentifier():
    nextIdentifierFileObj = open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME))
    nextIdentifierStr = nextIdentifierFileObj.read().strip()

    return int(nextIdentifierStr)

def setNextRequestIdentifier(nextIdentifier):
    nextIdentifierFileObj = open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME), 'w')
    nextIdentifierStr = str(nextIdentifier + 1)
    nextIdentifierFileObj.write(nextIdentifierStr)

if __name__ == "__main__":
    load_dotenv()

    parser = argparse.ArgumentParser(prog=f'{argv[0]}')
    subparsers = parser.add_subparsers(help="sub-command help", dest="command")

    killParser = subparsers.add_parser("kill", help="Used to stop a running replica")
    killParser.add_argument("url", help="<host>:<port>")

    membersParser = subparsers.add_parser("members", help="Used to list state of current cluster members")
    membersParser.add_argument("-table", action="store_true")

    putParser = subparsers.add_parser("put", help="Used to create or update a key-value pair")
    putParser.add_argument("key", help="To be used as a key for the mapping")
    putParser.add_argument("value", help="To be used as a value for the mapping")

    getParser = subparsers.add_parser("get", help="Used to read value associated with a given key")
    getParser.add_argument("key", help="Key whose associated value will be retreived")

    args = parser.parse_args()

    if args.command == "kill":
        killReplica(args.url)
    elif args.command == "members":
        listClusterMembers(args.table)
    elif args.command == "put":
        try:
            print(put(args.key, args.value))
        except PutFailureException:
            print("PUT Request Failed")
    elif args.command == "get":
        try:
            print(get(args.key))
        except GetFailureException:
            print("GET Request Failed")
    else:
        parser.error("No command provided: must be one of (kill, members, put, get)")
