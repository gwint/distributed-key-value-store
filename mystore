#!/usr/bin/python3

import argparse
from sys import argv, exit, path
from os import getenv, path as ospath
from random import randrange, seed
import logging
from socket import gethostname, gethostbyname, timeout
from time import sleep
import traceback

path.append('gen-py')

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer
from dotenv import load_dotenv

REQUEST_IDENTIFIER_ENV_VAR_NAME = "REQUEST_ID_FILE"
MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME = "CURRENT_LEADER_INFO_FILE"
RPC_TIMEOUT_ENV_VAR_NAME = "CMD_LINE_TOOL_TIMEOUT_MS"
NUM_REQUEST_RETRIES_ENV_VAR_NAME = "CMD_LINE_TOTAL_NUM_RETRIES_PER_REQUEST"
REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME = "CMD_LINE_TOOL_REST_PERIOD_BETWEEN_CALLS_MS"
NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME = "CMD_LINE_TOOL_NUM_REQUEST_RETRY_CYCLES_BEFORE_QUITTING"
CLUSTER_MEMBERSHIP_FILE_NAME_ENV_VAR_NAME = "CLUSTER_MEMBERSHIP_FILE"

from replicaservice import ReplicaService

logger = logging.getLogger(f'{argv[0]}_logger')
handler = logging.FileHandler(f'{argv[0]}.log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)

class PutFailureException(Exception):
    pass

class GetFailureException(Exception):
    pass

def isNullID(id):
    return (not id.hostname) and id.port == 0

def killReplica(url):
    if ':' not in url or list(url).count(':') != 1:
        print(f'Cannot kill replica at {url}: Invalid format (should be <host>:<port>)')
        exit(1)

    host, portStr = tuple(url.split(':'))
    port = int(portStr)

    transport = TSocket.TSocket(host, port)
    transport = TTransport.TBufferedTransport(transport)

    try:
        transport.open()

        protocol = TBinaryProtocol.TBinaryProtocol(transport)
        client = ReplicaService.Client(protocol)

        try:
            client.kill()

        except TTransport.TTransportException as e:
            logger.debug(f'Experienced error while attempting to kill replica at ({host}:{port})')

    except TTransport.TTransportException as e:
        logger.debug(f'Experienced error while setting up connection to attempt to kill replica at ({host}:{port})')

def listClusterMembers(isTableUsed):
    clusterInfo = {}

    with open(getenv(CLUSTER_MEMBERSHIP_FILE_NAME_ENV_VAR_NAME)) as membershipFileObj:
        line = membershipFileObj.readline()
        while line:
            host, port = tuple(line.split(':'))

            transport = TSocket.TSocket(host, int(port))
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()

                try:
                    protocol = TBinaryProtocol.TBinaryProtocol(transport)
                    client = ReplicaService.Client(protocol)
                    clusterInfo[(host,int(port))] = client.getInformation()

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while attempting to gather information from ({host}:{port})')
                    else:
                        logger.debug(f'Experienced a non-timeout error while attempting to gather information from ({host}:{port}): {str(e)}')

                    clusterInfo[(host, int(port))] = None

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced error while setting up connection to attempt to gather information from ({host}:{port})')
                clusterInfo[(host, int(port))] = None

            line = membershipFileObj.readline()

    displayClusterInfoInTable(clusterInfo) if isTableUsed else displayClusterInfoWithCommaSep(clusterInfo)

def displayClusterInfoInTable(clusterInfo):
    print("+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+")
    print(f'|{"Endpoint".center(23)}|{"Role".center(23)}|{"Term".center(23)}|{"Index".center(23)}|')
    print("+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+")

    for endpoint, replicaInformation in clusterInfo.items():
        endpointStr = f'http://{endpoint[0]}:{endpoint[1]}'.center(23)

        if replicaInformation:
            print(f'|{endpointStr}|{replicaInformation["role"].center(23)}|{replicaInformation["term"].center(23)}|{replicaInformation["index"].center(23)}|')
        else:
            print(f'|{endpointStr}|{"N/A".center(23)}|{"N/A".center(23)}|{"N/A".center(23)}|')

    print("+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+" + ("-" * 23) + "+")

def displayClusterInfoWithCommaSep(clusterInfo):
    count = 0
    for endpoint, replicaInformation in clusterInfo.items():
        if replicaInformation:
            print(f'{endpoint[0]},{endpoint[1]},{replicaInformation["role"]},{replicaInformation["term"]},{replicaInformation["index"]}', end='')
        else:
            print(f'{endpoint[0]},{endpoint[1]},None', end='')

        if count < len(clusterInfo)-1:
            print(';', end='')

        count += 1

    print()

def get(key, numPastMappings):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())
    ret = getHelper(key, hostIP, nextRequestIdentifier, numPastMappings)

    return ret

def getHelper(key, clientIdentifier, requestNumber, numPastMappings):
    leaderInfo = getLeaderInfo()
    if not leaderInfo:
        leaderInfo = getRandomReplica()

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    currentRequestNumber = requestNumber
    host, port = leaderInfo

    for cycleNum in range(numCyclesBeforeQuitting):
        for retryNum in range(numRetriesBeforeChangingRequestID):
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()
                try:
                    protocol = TBinaryProtocol.TBinaryProtocol(transport)
                    client = ReplicaService.Client(protocol)

                    logger.debug(f'Now contacting ({host}:{port}) to resolve GET')

                    response = client.get(str(key), clientIdentifier, currentRequestNumber, numPastMappings)

                    if response.success:
                        logger.debug(f'GET request successfully resolved: {response.values} is the value retreived')
                        open(getenv(MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME), 'w').write(f'{host}:{port}')
                        setNextRequestIdentifier(currentRequestNumber + 1)

                        return response.values

                    elif isNullID(response.leaderID):
                        logger.debug(f'GET request unsuccessful and current leader is unknown')
                        host, port = getRandomReplica()
                    else:
                        logger.debug(f'GET request unsuccessful')
                        host = response.leaderID.hostname
                        port = response.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced error while creating connection to contact ({host}:{port}) to resolve GET')
                host, port = getRandomReplica()

            sleep(pauseDurationAfterRetryMS / 1000)

        currentRequestNumber += 1

    raise GetFailureException()

def put(key, value):
    nextRequestIdentifier = getNextRequestIdentifier()
    hostIP = gethostbyname(gethostname())
    ret = putHelper(key, value, hostIP, nextRequestIdentifier)

    return ret

def putHelper(key, value, clientIdentifier, requestNumber):
    leaderInfo = getLeaderInfo()
    if not leaderInfo:
        leaderInfo = getRandomReplica()

    numCyclesBeforeQuitting = int(getenv(NUM_RETRY_CYCLES_BEFORE_QUITTING_ENV_VAR_NAME))
    numRetriesBeforeChangingRequestID = int(getenv(NUM_REQUEST_RETRIES_ENV_VAR_NAME))
    pauseDurationAfterRetryMS = int(getenv(REST_PERIOD_BETWEEN_CALLS_ENV_VAR_NAME))

    currentRequestNumber = requestNumber
    host, port = leaderInfo

    for cycleNum in range(numCyclesBeforeQuitting):
        logger.debug(f'Now entering cycle {cycleNum} for PUT request')
        for retryNum in range(numRetriesBeforeChangingRequestID):
            logger.debug(f'Request Identifier {currentRequestNumber} being used for PUT attempt {retryNum}')
            transport = TSocket.TSocket(host, port)
            transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
            transport = TTransport.TBufferedTransport(transport)

            try:
                transport.open()
                protocol = TBinaryProtocol.TBinaryProtocol(transport)
                client = ReplicaService.Client(protocol)

                logger.debug(f'Now contacting ({host}:{port}) to resolve PUT')

                try:
                    response = client.put(str(key), str(value), clientIdentifier, currentRequestNumber)

                    if response.success:
                        logger.debug(f'PUT request successfully resolved: {key} => {value}')
                        open(getenv(MOST_RECENT_LEADER_ADDR_ENV_VAR_NAME), 'w').write(f'{host}:{port}')
                        setNextRequestIdentifier(currentRequestNumber + 1)

                        return True

                    elif isNullID(response.leaderID):
                        logger.debug(f'PUT request unsuccessful and current leader is unknown')
                        host, port = getRandomReplica()
                    else:
                        logger.debug(f'PUT request unsuccessful')
                        host = response.leaderID.hostname
                        port = response.leaderID.port

                except TTransport.TTransportException as e:
                    if isinstance(e.inner, timeout):
                        logger.debug(f'Experienced timeout error while contacting ({host}:{port})')

            except TTransport.TTransportException as e:
                logger.debug(f'Experienced transport error while contacting ({host}:{port}): {str(e)}')
                host, port = getRandomReplica()

            sleep((pauseDurationAfterRetryMS / 1000) * 2)

        currentRequestNumber += 1

    raise PutFailureException()

def getLeaderInfo():

    if ospath.exists(getenv("CURRENT_LEADER_INFO_FILE")):
        leaderInfoFileObj = open(getenv("CURRENT_LEADER_INFO_FILE"), 'r')
        leaderAddr = leaderInfoFileObj.read().strip()
        if not leaderAddr:
            return ()
        if ':' not in leaderAddr or list(leaderAddr).count(':') > 1:
            raise ValueError(f'{getenv("CURRENT_LEADER_INFO_FILE")} containing leader information is ill-formed: should have single line of the form <host>:<port>; {leaderAddr} does not comply.')

        return tuple(leaderAddr.split(':'))

    else:
        leaderInfoFileObj = open(getenv("CURRENT_LEADER_INFO_FILE"), 'w')
        randomHost, randomPort = getRandomReplica()
        leaderInfoFileObj.write(f'{randomHost}:{randomPort}\n')

        return (randomHost, randomPort)

def getRandomReplica():
    seed()

    replicaInfoFileObj = open(getenv("CLUSTER_MEMBERSHIP_FILE"), 'r')

    replicaInfo = []

    line = replicaInfoFileObj.readline()
    while line:
        line = line.strip()
        if not line:
            raise ValueError(f'{getenv("CLUSTER_MEMBERSHIP_FILE")} is ill-formed: each line shoudl be of the form <host>:<port>; {line} does not comply.')
        if ':' not in line or list(line).count(':') > 1:
            raise ValueError(f'{getenv("CLUSTER_MEMBERSHIP_FILE")} is ill-formed: the file must not be empty')

        host, portStr = tuple(line.strip().split(':'))
        port = int(portStr)

        replicaInfo.append((host, port))

        line = replicaInfoFileObj.readline()

    replicaInfoFileObj.close()

    return replicaInfo[randrange(len(replicaInfo))]

def start():
    try:
        with open(getenv(CLUSTER_MEMBERSHIP_FILE_NAME_ENV_VAR_NAME)) as membershipFileObj:
            for addr in membershipFileObj.readlines():
                host, portStr = tuple(addr.split(':'))
                port = int(portStr)

                transport = TSocket.TSocket(host, port)
                transport.setTimeout(int(getenv(RPC_TIMEOUT_ENV_VAR_NAME)))
                transport = TTransport.TBufferedTransport(transport)

                try:
                    transport.open()

                    try:
                        protocol = TBinaryProtocol.TBinaryProtocol(transport)
                        client = ReplicaService.Client(protocol)
                        client.start()

                    except TTransport.TTransportException as e:
                        logger.debug(f'Experienced error while attempting to start operation of replica at ({host}:{port})')

                except TTransport.TTransportException as e:
                    logger.debug(f'Experienced transport error while establishing connection to start replica at ({host}:{port}): {str(e)}')

    except FileNotFoundError:
        print(f'You must create a cluster.membership file that contains the host:port pairs for all replicas in the cluster')

def getNextRequestIdentifier():
    if not ospath.exists(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME)):
        with open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME), 'w') as nextIdentifierFileObj:
            nextIdentifierFileObj.write("0")

    nextIdentifierFileObj = open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME))
    nextIdentifierStr = nextIdentifierFileObj.read().strip()

    return int(nextIdentifierStr)

def setNextRequestIdentifier(nextIdentifier):
    nextIdentifierFileObj = open(getenv(REQUEST_IDENTIFIER_ENV_VAR_NAME), 'w')
    nextIdentifierStr = str(nextIdentifier)
    nextIdentifierFileObj.write(nextIdentifierStr)

if __name__ == "__main__":
    load_dotenv()

    parser = argparse.ArgumentParser(prog=f'{argv[0]}')
    subparsers = parser.add_subparsers(help="sub-command help", dest="command")

    startParser = subparsers.add_parser("start", help="Start operation of the cluster")

    killParser = subparsers.add_parser("kill", help="Used to stop a running replica")
    killParser.add_argument("url", help="<host>:<port>")

    membersParser = subparsers.add_parser("members", help="Used to list state of current cluster members")
    membersParser.add_argument("-table", action="store_true")

    putParser = subparsers.add_parser("put", help="Used to create or update a key-value pair")
    putParser.add_argument("key", help="To be used as a key for the mapping")
    putParser.add_argument("value", help="To be used as a value for the mapping")

    getParser = subparsers.add_parser("get", help="Used to read value associated with a given key")
    getParser.add_argument("key", help="Key whose associated value will be retreived")
    getParser.add_argument("-rev", nargs="?", type=int, default=0)

    args = parser.parse_args()

    if args.command == "start":
        start()
    elif args.command == "kill":
        killReplica(args.url)
    elif args.command == "members":
        listClusterMembers(args.table)
    elif args.command == "put":
        try:
            print(put(args.key, args.value))
        except PutFailureException:
            print("PUT Request Failed")
    elif args.command == "get":
        try:
            for val in get(args.key, args.rev):
                print(val)
        except GetFailureException:
            print("GET Request Failed")
    else:
        parser.error("No command provided: must be one of (start, kill, members, put, get)")
